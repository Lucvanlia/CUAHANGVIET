{"id":17007,"date":"2020-11-27T02:18:42","date_gmt":"2020-11-27T02:18:42","guid":{"rendered":"https:\/\/banhangviet.net\/?p=17007"},"modified":"2022-11-21T20:06:42","modified_gmt":"2022-11-21T20:06:42","slug":"the-fight-for-performance-is-reactive-programming","status":"publish","type":"post","link":"https:\/\/banhangviet.net\/the-fight-for-performance-is-reactive-programming\/","title":{"rendered":"The fight for performance Is reactive programming the right approach?"},"content":{"rendered":"<div id=\"toc\" style=\"background: #f9f9f9;border: 1px solid #aaa;margin-bottom: 1em;padding: 1em;width: 350px\">\n<p class=\"toctitle\" style=\"font-weight: 700;text-align: center\">Content<\/p>\n<ul class=\"toc_list\">\n<li><a href=\"#toc-0\">Checking if the site connection is secure<\/a><\/li>\n<li><a href=\"#toc-1\">Reactive programming<\/a><\/li>\n<li><a href=\"#toc-2\">How the current thread per task model works<\/a><\/li>\n<li><a href=\"#toc-3\">OpenShift developer sandbox (free)<\/a><\/li>\n<li><a href=\"#toc-4\">Why OpenShift is essential for containerized applications<\/a><\/li>\n<li><a href=\"#toc-5\">Project Loom: Lightweight Java threads<\/a><\/li>\n<li><a href=\"#toc-7\">Getting Started With Reactive<\/a><\/li>\n<\/ul>\n<\/div>\n<p>The Kotlin equivalent uses coroutine contexts as synchronization points.<\/p>\n<p>Each one is a stage, and the resultant CompletablFuture is returned back to the web-framework. With Loom, a more powerful abstraction is the savior. We have seen this repeatedly on how abstraction with syntactic sugar, makes one effectively write programs. Whether it was FunctionalInterfaces in JDK8, for-comprehensions in Scala.<\/p>\n<p>You can learn more about reactive programming here and in this free e-book by Clement Escoffier. Join developers across the globe for live and virtual events led by Red Hat technology experts. Red Hat OpenShift Open, hybrid-cloud Kubernetes platform to build, run, and scale container-based applications &#8212; now with developer tools, CI\/CD, and release management. I maintain some skepticism, as the research typically shows a poorly scaled system, which is transformed into a lock avoidance model, then shown to be better. I have yet to see one which unleashes some experienced developers to analyze the synchronization behavior of the system, transform it for scalability, then measure the result. But, even if that were a win experienced developers are a rare and expensive commodity; the heart of scalability is really financial.<\/p>\n<p>To reach the same level of convenience in Java you probably have to move the nested code into separate functions to actually keep it readable. But once you did that, you loose the context of \u201cLoom\u201d. This means that you cannot see any more if a function is suited for virtual threads or not.<\/p>\n<h2 id=\"toc-0\">Checking if the site connection is secure<\/h2>\n<p>Also, our Fruit Panache entity exposes methods using these types, so we only need to implement the glue. On the other side, the reactive model relies on non-blocking I\/Os and a different <a href=\"https:\/\/globalcloudteam.com\/\">https:\/\/globalcloudteam.com\/<\/a> execution model. Non-blocking I\/O provides an efficient way to deal with concurrent I\/O. A minimal amount of threads called I\/O threads, can handle many concurrent I\/O.<\/p>\n<div style='border: grey solid 1px;padding: 12px'>\n<h3>Introducing Helidon N\u00edma Using Virtual Threads to Achieve Simplicity and High Performance &#8211; InfoQ.com<\/h3>\n<p>Introducing Helidon N\u00edma Using Virtual Threads to Achieve Simplicity and High Performance.<\/p>\n<p>Posted: Fri, 16 Sep 2022 07:00:00 GMT [<a href='https:\/\/news.google.com\/__i\/rss\/rd\/articles\/CBMiPGh0dHBzOi8vd3d3LmluZm9xLmNvbS9uZXdzLzIwMjIvMDkvaW50cm9kdWNpbmctaGVsaWRvbi1uaW1hL9IBAA?oc=5' rel=\"nofollow\">source<\/a>]\n<\/div>\n<p>RESTEasy Reactive automatically maps the list into a JSON Array, except if instructed otherwise. Verify that Maven is using the Java version you expect. If you have multiple JDKs installed, make sure Maven is using the expected one. You can verify which JDK Maven uses by running mvn &#8211;version. This repository contains an experiment that uses a Spring Boot application with Virtual Threads.<\/p>\n<h2 id=\"toc-1\">Reactive programming<\/h2>\n<p>And comes back to continue the execution of the original virtual-thread whenever unparked. But here, you have a single carrier-thread in a way executing the body of multiple virtual-threads, switching from one to another when blocked. The HTTP server has a dedicated pool of threads. When a request comes in, a thread  carries the task up until it reaches the DB, wherein the task has to wait for the response from DB.<\/p>\n<p><img decoding=\"async\" class='aligncenter' style='margin-left:auto;margin-right:auto' src=\"https:\/\/globalcloudteam.com\/wp-content\/uploads\/2022\/02\/test-management-tools-comparison-768x512.jpg\" width=\"308px\" alt=\"java loom vs reactive\" \/><\/p>\n<p>But you may wonder what the differences and benefits are in comparison to the traditional and imperative model. Instead of allocating one OS thread per Java thread , Project Loom provides additional schedulers that schedule the multiple lightweight threads on the same OS thread. This approach provides better usage and much less context switching.<\/p>\n<p>This approach resolves the problem of context switching but introduces lots of complexity in the program itself. This type of program also scales better, which is one reason reactive programming has become very popular in recent times. Vert.x is one such library that helps Java developers write code in a reactive manner. If you do not do anything exotic, it does not matter, in terms of performance, if you submit all tasks with one executor or with two. The try-with-resources construct allows to introduce \u201cstructure into your concurrency\u201d. If you want to get more exotic, then Loom provides possibilities to restrict virtual threads to a pool of carrier threads.<\/p>\n<h2 id=\"toc-2\">How the current thread per task model works<\/h2>\n<p>At this point, the thread is returned to the thread pool and goes on to do the other tasks. When DB responds, it is again handled by some thread from the thread pool and it returns an HTTP response. In comes Project Loom with virtual threads that become the single unit of concurrency.<\/p>\n<p>The direct interaction with OS threads gives Java an edge on performance compared to Kotlin (but let\u2019s wait first for Loom to be released till we draw conclusions). For developers this means that structured concurrency is available in <a href=\"https:\/\/globalcloudteam.com\/javas-project-loom-and-virtual-threads\/\">project loom java<\/a> Kotlin and Java. As a result, the I\/O thread can handle multiple concurrent requests, improving the overall concurrency of the application. In the traditional and imperative approach, frameworks assign a thread to handle the request.<\/p>\n<p>In practice, you pass around your favourite languages abstraction of a context pointer. Loom is more about a native concurrency abstraction, which additionally helps one write asynchronous code. Given its a VM level abstraction, rather than just code level , It lets one implement asynchronous behavior but with reduce boiler plate.<\/p>\n<h2 id=\"toc-3\">OpenShift developer sandbox (free)<\/h2>\n<p>Java runtimes and frameworks Deploy your application safely and securely into your production environment without system or resource limitations. I understand that Netty is more than just Reactive\/Event Loop framework, it also has all the codecs for various protocols, which implementations will be useful somehow anyway, even afterwards. I may be wrong, but as far as I understand, the whole Reactive\/Event Loop thing, and Netty in particular, was invented as an answer to the C10K+ problem. It has obvious drawbacks, as all your code now becomes Async, with ugly callbacks, meaningless stack traces, and therefore hard to maintain and to reason about. As 1 indicates, there are tangible results that can be directly linked to this approach; and a few intangibles.<\/p>\n<p><img decoding=\"async\" class='aligncenter' style='margin-left:auto;margin-right:auto' src=\"https:\/\/globalcloudteam.com\/wp-content\/uploads\/2022\/09\/best-expense-management-software-2023-768x512.jpg\" width=\"302px\" alt=\"java loom vs reactive\" \/><\/p>\n<p>Currently reactive programming paradigms are often used to solve performance problems, not because they fit the problem. Those should be covered completely via project Loom. Note that this leaves the PEA divorced from the underlying system thread, because they are internally multiplexed between them. This is your concern about divorcing the concepts.<\/p>\n<h2 id=\"toc-4\">Why OpenShift is essential for containerized applications<\/h2>\n<p>A more realistic one would strive for collecting from a dynamic pool which kept one real thread for every blocked system call + one for every real CPU. At least that is what the folks behind Go came up with. To give some context here, I have been following Project Loom for some time now.<\/p>\n<ul>\n<li>Using virtual threads would give us the stream programming model, but keep it aligned with the underlying tools and ecosystems (AMP\/Profilers\/Debuggers\/Logging\/etc&#8230;<\/li>\n<li>Used for streaming programming and functional programming.<\/li>\n<li>Loom is more about a native concurrency abstraction, which additionally helps one write asynchronous code.<\/li>\n<li>Go&#8217;s language with goroutines was a solution, now they can write Sync code and also handle C10K+.<\/li>\n<\/ul>\n<p>Loom introduces coroutines, termed virtual threads, as native element into the JVM. The Loom development team chose not to deviate from existing syntax. The thread-API stays more-or-less the same. The big difference to Kotlin is that Loom\u2019s virtual threads are managed and scheduled by the JVM instead of the operating system. They skip the indirection via the traditional JVM thread abstraction.<\/p>\n<h2 id=\"toc-5\">Project Loom: Lightweight Java threads<\/h2>\n<p>The HTTP server just spawns virtual threads for every request. If there is an IO, the virtual thread just waits for the task to complete. Basically, there is no pooling business going on for the virtual threads. With loom, there isn&#8217;t a need to chain multiple CompletableFuture&#8217;s . And with each blocking operation encountered (ReentrantLock, i\/o, JDBC calls), the virtual-thread gets parked.<\/p>\n<h2 id=\"toc-6\">Structured concurrency: will Java Loom beat Kotlin\u2019s coroutines?<\/h2>\n<p>Further, each thread has some memory allocated to it, and only a limited number of threads can be handled by the operating system. This approach gives developers plenty of room to make mistakes or confuse existing and unrelated concurrency abstractions with the new constructs. In addition, business intent is blurred by the extra verbosity of Java. Project Loom is coming to the JDK soon and proposes a virtual thread-based model. The Quarkus architecture is ready to support Loom as soon as it\u2019s become globally available.<\/p>\n<p>To write to a database, we need a transaction. So we use Panache.withTransaction to get one and call the persist method when we receive the transaction. The persist method is also returning a Uni. This Uni emits the result of the insertion of the fruit in the database. Once the insertion completes (and that\u2019s our continuation), we create a 201 CREATED response. RESTEasy Reactive automatically reads the request body as  JSON and creates the Fruit instance.<\/p>\n<p>Project Loom team has done a great job on this front, and Fiber can take the Runnable interface. To be complete, note that Continuation also implements Runnable. Consider an application in which all the threads are waiting for a database to respond.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Content Checking if the site connection is secure Reactive programming How the current thread per task model works OpenShift developer sandbox (free) Why OpenShift is essential for containerized applications Project Loom: Lightweight Java threads Getting Started With Reactive The Kotlin equivalent uses coroutine contexts as synchronization points. Each one is a stage, and the resultant [&#8230;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[2236],"tags":[],"class_list":["post-17007","post","type-post","status-publish","format-standard","hentry","category-software-development"],"_links":{"self":[{"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/posts\/17007"}],"collection":[{"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/comments?post=17007"}],"version-history":[{"count":1,"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/posts\/17007\/revisions"}],"predecessor-version":[{"id":17008,"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/posts\/17007\/revisions\/17008"}],"wp:attachment":[{"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/media?parent=17007"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/categories?post=17007"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/banhangviet.net\/wp-json\/wp\/v2\/tags?post=17007"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}